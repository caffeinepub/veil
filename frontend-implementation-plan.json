{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Complete VEIL Platform â€” Auth, Posts, Emotions, Reactions, Comments, Flagging, Admin, Invites, Seat Counter",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Ensure full Internet Identity authentication flow with session persistence, logout, role detection, and route protection",
      "acceptanceCriteria": [
        "Unauthenticated users visiting protected routes are redirected to /login",
        "Non-admin users visiting /admin are shown an access-denied screen",
        "After Internet Identity login, users are redirected to the community feed",
        "Logout clears session state and redirects to login",
        "Auth state (isAuthenticated, userId, role) is correctly exposed via useAuth hook"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useAuth.ts",
          "operation": "modify",
          "description": "Ensure the useAuth hook correctly exposes isAuthenticated (checks identity existence), userId (returns principal), and role (from backend query). Verify logout calls clear() from useInternetIdentity and invalidates all queries."
        },
        {
          "path": "frontend/src/components/ProtectedRoute.tsx",
          "operation": "modify",
          "description": "Verify ProtectedRoute redirects unauthenticated users to /login using React Router navigation, shows loading spinner during auth initialization, and renders children only when authenticated."
        },
        {
          "path": "frontend/src/components/AdminRoute.tsx",
          "operation": "modify",
          "description": "Verify AdminRoute redirects unauthenticated users to /login, displays access-denied screen for non-admin authenticated users, and renders children only for authenticated admins. Use authorization component's role check capability."
        },
        {
          "path": "frontend/src/pages/LoginPage.tsx",
          "operation": "modify",
          "description": "Ensure LoginPage redirects authenticated users to /community after successful Internet Identity login. Use authorization component to support the authentication flow. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/Header.tsx",
          "operation": "modify",
          "description": "Verify Header displays correct navigation links based on authentication state and role. Ensure logout button calls the logout function from useAuth and clears all cached data."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Ensure fully functional post creation with emotion selection, word count enforcement, visibility toggle, and acknowledgment modals",
      "acceptanceCriteria": [
        "Emotion type selector renders all three types (happy, confess, broke) with correct EmotionBadge styling",
        "Word count enforcement prevents submission below 24 words for emotion types that require it",
        "EntryProtectionModal appears on page load and must be acknowledged before composing",
        "PublicPostWarningModal appears when visibility is set to public and must be acknowledged before submit",
        "Successful submission creates the post in the backend and navigates to /my-posts",
        "Post appears on MyPostsPage with correct emotion badge and visibility status"
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/PostCreationPage.tsx",
          "operation": "modify",
          "description": "Verify emotion type selector renders all three EmotionType values (happy, confess, broke) using EmotionBadge components. Ensure word count validation uses wordCounter utility to enforce 24-word minimum for applicable emotion types before enabling submit. Wire up EntryProtectionModal to block composition until acknowledged. Wire up PublicPostWarningModal to appear when visibility is public and block submission until acknowledged. After successful post creation via useCreatePost mutation, navigate to /my-posts using React Router."
        },
        {
          "path": "frontend/src/components/EntryProtectionModal.tsx",
          "operation": "modify",
          "description": "Ensure EntryProtectionModal is non-dismissible (no close button, no outside click dismiss) and requires explicit acknowledgment button click before allowing the user to proceed with post composition."
        },
        {
          "path": "frontend/src/components/PublicPostWarningModal.tsx",
          "operation": "modify",
          "description": "Ensure PublicPostWarningModal is non-dismissible and only appears when visibility is set to public. Require explicit 'I understand' button click to acknowledge the warning before allowing post submission."
        },
        {
          "path": "frontend/src/components/EmotionBadge.tsx",
          "operation": "modify",
          "description": "Verify EmotionBadge renders correct styling for each EmotionType (happy, confess, broke) using CSS custom properties and theme tokens defined in frontend/src/index.css and frontend/tailwind.config.js."
        },
        {
          "path": "frontend/src/utils/wordCounter.ts",
          "operation": "modify",
          "description": "Verify wordCounter utility correctly counts words and checks minimum word count (24 words). Ensure helper function identifies which emotion types require the minimum word count."
        },
        {
          "path": "frontend/src/pages/MyPostsPage.tsx",
          "operation": "modify",
          "description": "Ensure MyPostsPage displays all user posts sorted by date with correct EmotionBadge and visibility status indicators. Verify posts appear after creation."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Display contextual guidance when user selects 'broke' emotion type during post creation",
      "acceptanceCriteria": [
        "Selecting 'broke' emotion type renders a visible guidance callout below the emotion selector",
        "Guidance text does not appear for 'happy' or 'confess' emotion types",
        "Callout is styled distinctly (uses the 'broke' emotion color token) and does not obstruct the content textarea",
        "Guidance does not block form submission"
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/PostCreationPage.tsx",
          "operation": "modify",
          "description": "Add conditional rendering of guidance callout when emotionType state equals 'broke'. Display a highlighted callout with text advising that this mode is for genuine distress and offering a brief grounding prompt. Style using the 'broke' emotion color token from Tailwind config. Position below emotion selector without obstructing textarea. Do not block form submission."
        }
      ]
    },
    {
      "id": "REQ-4",
      "summary": "Ensure reaction system is fully functional on public posts with text reactions persisted and displayed",
      "acceptanceCriteria": [
        "Reaction input and submit button are visible on PublicPostCard for non-authors",
        "Reaction input and submit button are hidden for the post's own author",
        "Submitting a reaction calls the backend and optimistically or reactively updates the displayed reaction list",
        "Reactions persist across page refreshes",
        "Reaction count is visible on each post card"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/PublicPostCard.tsx",
          "operation": "modify",
          "description": "Verify PublicPostCard displays text reaction input and submit button only for non-authors (compare current user principal with post.author). Hide reaction UI for the post's own author. Wire up useAddTextReaction mutation to submit reactions. Display reaction list using useGetTextReactionsForPost query. Show reaction count. Ensure reactions persist by refetching after mutation success."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Verify useAddTextReaction mutation calls backend actor.addTextReaction and invalidates the text reactions query for the post. Verify useGetTextReactionsForPost query fetches reactions for a given postId. Ensure query keys are consistent and mutations trigger refetches."
        }
      ]
    },
    {
      "id": "REQ-5",
      "summary": "Ensure comment system is fully functional on public posts with comments persisted and displayed",
      "acceptanceCriteria": [
        "Comment input and submit button are visible on PublicPostCard for non-authors",
        "Comment input and submit button are hidden for the post's own author",
        "Submitting a comment calls the backend and updates the displayed comment list",
        "Comments persist across page refreshes",
        "Comment count is visible on each post card"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/PublicPostCard.tsx",
          "operation": "modify",
          "description": "Verify PublicPostCard displays comment input and submit button only for non-authors. Hide comment UI for the post's own author. Wire up useAddComment mutation to submit comments. Display comment list using useGetCommentsByPost query. Show comment count. Ensure comments persist by refetching after mutation success."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Verify useAddComment mutation calls backend actor.addComment and invalidates the comments query for the post. Verify useGetCommentsByPost query fetches comments for a given postId. Ensure query keys are consistent and mutations trigger refetches."
        }
      ]
    },
    {
      "id": "REQ-6",
      "summary": "Ensure flagging system is fully functional on public posts with flag actions tracked in backend",
      "acceptanceCriteria": [
        "Flag button is visible on PublicPostCard for non-authors",
        "Flag button is hidden for the post's own author",
        "Clicking flag calls the backend and increments the post's report count",
        "Flagged posts with sufficient report count appear in the AdminFlaggedPosts tab",
        "Admins can remove flagged posts from the AdminFlaggedPosts tab",
        "Flagged comments appear in AdminFlaggedComments and can be removed by admins"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/PublicPostCard.tsx",
          "operation": "modify",
          "description": "Verify PublicPostCard displays flag button only for non-authors. Hide flag button for the post's own author. Wire up useFlagPost mutation to call backend actor.flagPost. Display success/error feedback after flagging."
        },
        {
          "path": "frontend/src/components/AdminFlaggedPosts.tsx",
          "operation": "modify",
          "description": "Verify AdminFlaggedPosts lists flagged posts with report counts and content. Wire up useAdminRemovePost mutation with confirmation dialog to permanently delete flagged posts. Refetch flagged posts after removal."
        },
        {
          "path": "frontend/src/components/AdminFlaggedComments.tsx",
          "operation": "modify",
          "description": "Verify AdminFlaggedComments lists flagged comments with author pseudonym, timestamp, and post ID. Wire up useDeleteComment mutation with confirmation dialog to permanently remove flagged comments. Refetch flagged comments after removal."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Verify useFlagPost mutation calls backend actor.flagPost. Verify useAdminGetFlaggedPosts query fetches flagged posts for admin. Verify useDeleteComment mutation calls backend actor.deleteComment and invalidates relevant queries. Ensure all query keys are consistent."
        }
      ]
    },
    {
      "id": "REQ-7",
      "summary": "Ensure admin dashboard is fully functional with all six tabs operational and ecosystem silence banner",
      "acceptanceCriteria": [
        "All six admin tabs render with correct data fetched from the backend",
        "Remove post action in AdminPublicPostsList permanently deletes the post after confirmation",
        "Suspend, unsuspend, cooldown, and remove actions in AdminAllUsersTab work correctly",
        "Invite code generation creates a new code; revoke removes it; copy link copies to clipboard",
        "AdminFlaggedPosts and AdminFlaggedComments display flagged items and support removal",
        "AdminEmotionalAlertsTab lists users with 5+ broke posts in 3 consecutive days",
        "AdminCrisisRiskTab lists crisis-flagged posts with check-in and resource-send actions",
        "Ecosystem silence banner appears when no public posts in 5 days and allows publishing a prompt"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/AdminDashboard.tsx",
          "operation": "modify",
          "description": "Verify AdminDashboard renders all six tabs: Public Posts, User Management, Invite Codes, Flagged Content (with sub-tabs for posts and comments), Emotional Alerts, and Crisis Risk. Wire up ecosystem silence banner to appear when no public posts exist in the last 5 days (check via useGetPublicPosts query), allowing admin to publish a prompt post. Ensure tab navigation works correctly."
        },
        {
          "path": "frontend/src/components/AdminPublicPostsList.tsx",
          "operation": "modify",
          "description": "Verify AdminPublicPostsList displays all public posts sorted by date with EmotionBadge. Wire up useAdminRemovePost mutation with confirmation dialog to permanently delete posts. Refetch public posts after removal."
        },
        {
          "path": "frontend/src/components/AdminAllUsersTab.tsx",
          "operation": "modify",
          "description": "Verify AdminAllUsersTab lists all users with suspend, unsuspend, cooldown, and remove actions. Wire up useAdminSuspendUser, useAdminUnsuspendUser, useAdminApplyCooldown, and useAdminRemoveUser mutations with confirmation dialogs. Refetch users after each action."
        },
        {
          "path": "frontend/src/components/AdminInviteCodes.tsx",
          "operation": "modify",
          "description": "Verify AdminInviteCodes allows admins to generate new invite codes via useGenerateInviteCode mutation, copy invite links to clipboard, and revoke unused codes via useRevokeInviteCode mutation. Use invite-links component to support invite code management. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/AdminEmotionalAlertsTab.tsx",
          "operation": "modify",
          "description": "Verify AdminEmotionalAlertsTab lists users flagged for posting 5+ 'broke' entries within 3 consecutive days using useGetEmotionalAlerts query. Display pseudonym and post count for each flagged user."
        },
        {
          "path": "frontend/src/components/AdminCrisisRiskTab.tsx",
          "operation": "modify",
          "description": "Verify AdminCrisisRiskTab displays posts flagged for crisis risk using useGetCrisisRiskPosts query. Wire up useSendCheckIn and useSendCrisisResources mutations to allow admins to send check-in messages or crisis resources to post authors. Include useAdminRemovePost mutation to remove crisis-flagged posts after confirmation."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Verify all admin-related queries and mutations are correctly implemented: useAdminRemovePost, useAdminSuspendUser, useAdminUnsuspendUser, useAdminApplyCooldown, useAdminRemoveUser, useGenerateInviteCode, useRevokeInviteCode, useGetEmotionalAlerts, useGetCrisisRiskPosts, useSendCheckIn, useSendCrisisResources. Ensure all mutations invalidate relevant queries and handle loading/error states. Use invite-links component for invite code operations. Verify the component's usage instructions before implementing."
        }
      ]
    },
    {
      "id": "REQ-8",
      "summary": "Ensure invite code logic is fully functional with validation and consumption tracking",
      "acceptanceCriteria": [
        "Admin can generate a new invite code from AdminInviteCodes tab",
        "Generated code appears in the list with copy-link functionality",
        "SignupPage validates the invite code against the backend before allowing registration",
        "Using an invalid or already-used code displays a clear error message",
        "After successful registration with a code, the code is marked used and cannot be reused",
        "Admins can revoke unused codes"
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/SignupPage.tsx",
          "operation": "modify",
          "description": "Verify SignupPage validates invite code using useValidateInviteCode query before allowing registration. Display clear error message for invalid or used codes. Wire up useRegister mutation to create user account with validated invite code. After successful registration, navigate to login page. Use invite-links component to support invite code validation during signup. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/AdminInviteCodes.tsx",
          "operation": "modify",
          "description": "Verify AdminInviteCodes tab allows generating new codes via useGenerateInviteCode mutation. Display generated codes in list with copy-link functionality (copy full URL with code parameter to clipboard). Wire up useRevokeInviteCode mutation to revoke unused codes. Use invite-links component to support invite code management. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Verify useValidateInviteCode query calls backend actor.validateInviteCode. Verify useRegister mutation calls backend actor.register with pseudonym, region, and inviteCode. Verify useGenerateInviteCode mutation calls backend actor.generateInviteCode. Verify useRevokeInviteCode mutation calls backend actor.revokeInviteCode. Use invite-links component for invite code operations. Verify the component's usage instructions before implementing."
        }
      ]
    },
    {
      "id": "REQ-9",
      "summary": "Display remaining seat count on SignupPage fetched live from backend",
      "acceptanceCriteria": [
        "SignupPage displays remaining seat count fetched from the backend",
        "Seat count decrements correctly after each successful registration",
        "If no seats remain, the signup form is disabled with an appropriate message",
        "Seat count reflects the current state on page load"
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/SignupPage.tsx",
          "operation": "modify",
          "description": "Wire up useGetSeatInfo query to fetch remaining seat count from backend actor.getSeatInfo. Display seat count prominently on SignupPage. Disable signup form with appropriate message when remaining seats reach zero. Refetch seat count after successful registration to show updated availability."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Verify useGetSeatInfo query calls backend actor.getSeatInfo and returns SeatInfo (maxSeats, currentSeats). Ensure query is refetched after user registration via useRegister mutation."
        }
      ]
    },
    {
      "id": "REQ-10",
      "summary": "Wire up all React Query hooks to call backend Motoko actor methods with consistent query keys and mutation invalidations",
      "acceptanceCriteria": [
        "Every backend method exposed by the Motoko actor has a corresponding React Query hook in useQueries.ts",
        "Mutations call invalidateQueries on the correct query keys after success",
        "Loading and error states from queries are handled in all consuming components",
        "No stale data is shown after a mutation completes"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Audit all React Query hooks to ensure every backend method in backend.d.ts has a corresponding hook. Verify all mutations call queryClient.invalidateQueries with correct query keys after success. Ensure consistent query key naming (e.g., ['posts', 'public'], ['posts', 'user'], ['admin', 'users']). Add missing hooks if any backend methods are not covered. Verify authorization component usage for admin checks. Use invite-links component for invite code operations. Verify both components' usage instructions before implementing."
        },
        {
          "path": "frontend/src/pages/DashboardPage.tsx",
          "operation": "modify",
          "description": "Verify all query loading and error states from useQueries hooks are properly handled and displayed to users. Show loading skeletons during data fetches. Display error messages when mutations fail."
        },
        {
          "path": "frontend/src/pages/CommunityFeedPage.tsx",
          "operation": "modify",
          "description": "Verify useGetPublicPosts query loading and error states are handled. Show loading skeletons during fetch. Display error message on fetch failure. Ensure empty state is shown when no public posts exist."
        },
        {
          "path": "frontend/src/pages/MyPostsPage.tsx",
          "operation": "modify",
          "description": "Verify useGetMyPosts query loading and error states are handled. Show loading skeleton during fetch. Display error message on fetch failure. Ensure empty state is shown when user has no posts."
        }
      ]
    }
  ]
}