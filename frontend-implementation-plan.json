{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Wire frontend hooks to complete backend â€” final integration pass",
  "requirements": [
    {
      "id": "REQ-62",
      "summary": "Update useQueries.ts to correctly call all backend functions with exact Candid interface parameter shapes and return types, ensuring all query hooks return data without errors and all mutation hooks invalidate relevant React Query cache keys on success",
      "acceptanceCriteria": [
        "All query hooks (getMyProfile, getMyPosts, getPublicPosts, isAdmin, getMySubscriptionStatus) return data without errors when the actor is available.",
        "All mutation hooks (createPost, editPost, deletePost, setPostPrivacy, addReaction, register) call the correct backend function with the correct argument types.",
        "getMyReaction accepts a postId string and returns the optional ReactionType.",
        "No TypeScript type errors are present in useQueries.ts.",
        "Each mutation hook invalidates the relevant React Query cache keys on success so the UI reflects updated state without a manual refresh."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Update all query and mutation hooks to match the exact Candid interface from backend.d.ts. Ensure createPost calls actor.createPost(emotionType, content) and returns the Result. Ensure editPost calls actor.editPost(postId, newContent). Ensure deletePost calls actor.deletePost(postId). Ensure setPostPrivacy calls actor.setPostPrivacy(postId, isPrivate). Ensure addReaction calls actor.addReaction(postId, reactionType) and returns the Result. Ensure getMyReaction calls actor.getMyReaction(postId) and returns ReactionType | null. Ensure getMyPosts calls actor.getMyPosts(). Ensure getPublicPosts calls actor.getPublicPosts(). Ensure getMyProfile calls actor.getMyProfile() and returns User | null. Ensure isAdmin calls actor.isAdmin() and returns boolean. Ensure register calls actor.register(pseudonym, region, inviteCode). Ensure validateInviteCode calls actor.validateInviteCode(code). Ensure getMySubscriptionStatus calls actor.getMySubscriptionStatus(). Add proper React Query invalidation on success for createPost (invalidate 'myPosts'), editPost (invalidate 'myPosts'), deletePost (invalidate 'myPosts'), setPostPrivacy (invalidate 'myPosts' and 'publicPosts'), addReaction (invalidate 'publicPosts'), and register (invalidate 'myProfile'). Ensure all mutation hooks use useMutation from @tanstack/react-query. Ensure all query hooks use useQuery with proper enabled flags. Verify all parameter types match the backend.d.ts interface exactly."
        }
      ]
    },
    {
      "id": "REQ-63",
      "summary": "Ensure SignupPage calls the register mutation with correct arguments, handles Result variants from the backend, and routes to dashboard on success or displays error message on failure",
      "acceptanceCriteria": [
        "Submitting a valid invite code, pseudonym, and region creates a user and navigates to /dashboard.",
        "Submitting an invalid or already-used invite code shows the backend error text inline without a page reload.",
        "Submitting when capacity is reached (100 members) shows the appropriate error message."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/SignupPage.tsx",
          "operation": "modify",
          "description": "Update the SignupPage component to call the register mutation from useQueries with arguments (pseudonym, region, inviteCode) in the correct order matching the backend interface. Wrap the mutation call in a try-catch block to handle Result variants. On success, navigate to '/dashboard' using useNavigate from @tanstack/react-router. On error, display the backend error message inline in the form without a page reload. Ensure the form validates invite code, pseudonym, and region before submission. Handle specific error messages for invalid invite codes, already-used codes, and capacity-reached scenarios."
        }
      ]
    },
    {
      "id": "REQ-64",
      "summary": "Ensure PostCreationPage calls the createPost mutation with correct arguments, handles Result returned by backend, and navigates to My Posts page on success or shows error inline on failure",
      "acceptanceCriteria": [
        "A successful createPost call navigates the user to /my-posts.",
        "A backend rejection (expired subscription, word count, suspended) is displayed as an inline error on the form.",
        "The post button remains disabled and shows the word-count prompt when Confess/Happy content is fewer than 24 words."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/PostCreationPage.tsx",
          "operation": "modify",
          "description": "Update the PostCreationPage component to call the createPost mutation from useQueries with arguments (emotionType, content) in the correct order matching the backend interface. Wrap the mutation call in a try-catch block to handle Result variants. On success, navigate to '/my-posts' using useNavigate from @tanstack/react-router. On error, display the backend error message inline in the form without a page reload. Ensure the submit button is disabled when word count is below MIN_WORDS_CONFESS_HAPPY (24) for Confess/Happy emotion types. Show a word-count prompt when the button is disabled. Handle specific error messages for expired subscription, insufficient word count, and suspended user scenarios."
        }
      ]
    },
    {
      "id": "REQ-65",
      "summary": "Ensure PostCard calls editPost, deletePost, and setPostPrivacy mutations with correct arguments, handles Result variants, and invalidates 'myPosts' and 'publicPosts' query keys on success for immediate UI updates",
      "acceptanceCriteria": [
        "Editing a post with reactionCount = 0 updates the card content without a page reload.",
        "Attempting to edit a post with reactionCount > 0 shows the backend error inline.",
        "Toggling a post public shows the confirmation dialog, calls setPostPrivacy(postId, false), and updates the card's status badge on success.",
        "Toggling a post private immediately calls setPostPrivacy(postId, true) and updates the badge.",
        "Deleting a post removes it from the list without a page reload."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/PostCard.tsx",
          "operation": "modify",
          "description": "Update the PostCard component to call editPost mutation with arguments (postId, newContent) when editing. Wrap the mutation call in a try-catch block to handle Result variants. On success, exit edit mode and rely on automatic query invalidation to refresh the list. On error, display the backend error message inline in the edit form. Update the setPostPrivacy mutation call to pass (postId, isPrivate) as arguments. For toggling public, show a confirmation dialog before calling setPostPrivacy(postId, false). For toggling private, immediately call setPostPrivacy(postId, true). On success, the badge should update via query invalidation. Update the deletePost mutation call to pass postId as the argument. On success, the card should disappear from the list via query invalidation. Ensure all mutations are wired to the hooks from useQueries.ts. Handle specific error messages for non-editable posts (reactionCount > 0)."
        }
      ]
    },
    {
      "id": "REQ-66",
      "summary": "Ensure PublicPostCard calls addReaction mutation and getMyReaction query with correct arguments, displays user's existing reaction, and disables reaction buttons for post owner and already-reacted posts",
      "acceptanceCriteria": [
        "Reacting to a post calls addReaction(postId, reactionType) and invalidates the publicPosts query key.",
        "The user's existing reaction is highlighted/shown when getMyReaction returns a non-null value.",
        "The post owner's reaction buttons are disabled or hidden.",
        "A duplicate reaction attempt shows the backend error message inline without crashing the component."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/PublicPostCard.tsx",
          "operation": "modify",
          "description": "Update the PublicPostCard component to call getMyReaction query with postId as the argument. Use the returned ReactionType | null to highlight the user's existing reaction. Update the addReaction mutation call to pass (postId, reactionType) as arguments. Wrap the mutation call in a try-catch block to handle Result variants. On success, rely on automatic query invalidation to refresh the publicPosts list. On error, display the backend error message inline without crashing the component. Disable or hide reaction buttons when the current user is the post owner (compare identity.getPrincipal() with post.userId). Disable reaction buttons when getMyReaction returns a non-null value. Ensure the component uses useInternetIdentity to get the current user's identity for ownership checks."
        }
      ]
    },
    {
      "id": "REQ-67",
      "summary": "Ensure all admin functions are exposed as query or mutation hooks in useQueries.ts and correctly consumed by admin dashboard components with proper cache invalidation and isAdmin checks",
      "acceptanceCriteria": [
        "AdminPublicPostsList fetches via adminGetAllPublicPosts and the delete button calls adminDeletePost, refreshing the list on success.",
        "AdminUserManagement fetches via adminGetAllUsers and suspend/unsuspend buttons call adminSuspendUser/adminUnsuspendUser, updating the list on success.",
        "AdminInviteCodes fetches active codes, add calls addInviteCode, and revoke calls revokeInviteCode, all with cache invalidation.",
        "AdminUserPostHistory fetches via adminGetUserPosts with a Principal argument and displays results.",
        "All admin hooks check isAdmin and redirect non-admins before rendering sensitive data."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Add or verify query hooks for adminGetAllPublicPosts, adminGetAllUsers, adminGetUserPosts(userId: Principal), getInviteCodes, and getAllRSVPs. Add or verify mutation hooks for adminDeletePost(postId), adminSuspendUser(userId: Principal), adminUnsuspendUser(userId: Principal), addInviteCode(code), revokeInviteCode(code), and setSubscriptionStatus(userId: Principal, status: SubscriptionStatus). Ensure all admin query hooks are enabled only when isAdmin returns true. Ensure adminDeletePost invalidates 'adminPublicPosts' on success. Ensure adminSuspendUser and adminUnsuspendUser invalidate 'adminUsers' on success. Ensure addInviteCode and revokeInviteCode invalidate 'inviteCodes' on success. Ensure setSubscriptionStatus invalidates 'adminUsers' on success. Ensure adminGetUserPosts accepts a Principal argument and calls actor.adminGetUserPosts(userId). Verify all parameter types and return types match backend.d.ts exactly."
        },
        {
          "path": "frontend/src/components/AdminPublicPostsList.tsx",
          "operation": "modify",
          "description": "Update the AdminPublicPostsList component to use the adminGetAllPublicPosts query hook from useQueries.ts. Update the delete button to call the adminDeletePost mutation hook with postId as the argument. Wrap the mutation call in a try-catch block to handle errors. On success, rely on automatic query invalidation to refresh the list. On error, display the backend error message inline. Ensure the component checks isAdmin before rendering sensitive data and redirects non-admins."
        },
        {
          "path": "frontend/src/components/AdminUserManagement.tsx",
          "operation": "modify",
          "description": "Update the AdminUserManagement component to use the adminGetAllUsers query hook from useQueries.ts. Update the suspend button to call the adminSuspendUser mutation hook with userId (Principal) as the argument. Update the unsuspend button to call the adminUnsuspendUser mutation hook with userId (Principal) as the argument. Update the subscription status dropdown to call the setSubscriptionStatus mutation hook with (userId, status) as arguments. Wrap all mutation calls in try-catch blocks to handle errors. On success, rely on automatic query invalidation to refresh the list. On error, display the backend error message inline. Ensure the component checks isAdmin before rendering sensitive data and redirects non-admins."
        },
        {
          "path": "frontend/src/components/AdminInviteCodes.tsx",
          "operation": "modify",
          "description": "Update the AdminInviteCodes component to use the getInviteCodes query hook from useQueries.ts to fetch all invite codes. Update the add button to call the addInviteCode mutation hook with code as the argument. Update the revoke button to call the revokeInviteCode mutation hook with code as the argument. Wrap all mutation calls in try-catch blocks to handle errors. On success, rely on automatic query invalidation to refresh the list. On error, display the backend error message inline. Ensure the component checks isAdmin before rendering sensitive data and redirects non-admins."
        },
        {
          "path": "frontend/src/components/AdminUserPostHistory.tsx",
          "operation": "modify",
          "description": "Update the AdminUserPostHistory component to use the adminGetUserPosts query hook from useQueries.ts. Ensure the query hook accepts a Principal argument (userId) and passes it to actor.adminGetUserPosts(userId). Display the returned posts in the component. Update the delete button to call the adminDeletePost mutation hook with postId as the argument. Wrap the mutation call in a try-catch block to handle errors. On success, rely on automatic query invalidation to refresh the list. On error, display the backend error message inline. Ensure the component checks isAdmin before rendering sensitive data and redirects non-admins."
        }
      ]
    },
    {
      "id": "REQ-68",
      "summary": "Ensure DashboardPage and PostCreationPage read subscription status from getMySubscriptionStatus query and correctly pass it to SubscriptionBanner and subscription-gating logic so expired users see the banner and cannot submit posts or go public",
      "acceptanceCriteria": [
        "Users with #expired subscription see the SubscriptionBanner on the dashboard and post creation page.",
        "The post creation form submit button is blocked with an inline message for expired users.",
        "The 'Go Public' button on PostCard is blocked with an inline message for expired users.",
        "Users with #grace or #active subscription do not see the subscription banner and can post and go public normally."
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/DashboardPage.tsx",
          "operation": "modify",
          "description": "Update the DashboardPage component to call the getMySubscriptionStatus query hook from useQueries.ts. Use the returned SubscriptionStatus to conditionally render the SubscriptionBanner component when the status is 'expired'. Pass the subscription status to any child components that need it for gating logic. Ensure the component handles loading and error states gracefully."
        },
        {
          "path": "frontend/src/pages/PostCreationPage.tsx",
          "operation": "modify",
          "description": "Update the PostCreationPage component to call the getMySubscriptionStatus query hook from useQueries.ts. Use the returned SubscriptionStatus with the canCreatePost helper from subscriptionHelpers.ts to disable the submit button when the status is 'expired'. Display an inline message explaining that the user cannot post because their subscription has expired. Conditionally render the SubscriptionBanner component when the status is 'expired'. Ensure the component handles loading and error states gracefully."
        },
        {
          "path": "frontend/src/components/PostCard.tsx",
          "operation": "modify",
          "description": "Update the PostCard component to accept a subscriptionStatus prop (SubscriptionStatus). Use the canGoPublic helper from subscriptionHelpers.ts to disable the 'Go Public' button when the status is 'expired'. Display an inline message explaining that the user cannot make their post public because their subscription has expired. Ensure the 'Go Private' button remains functional regardless of subscription status."
        },
        {
          "path": "frontend/src/pages/MyPostsPage.tsx",
          "operation": "modify",
          "description": "Update the MyPostsPage component to call the getMySubscriptionStatus query hook from useQueries.ts. Pass the returned SubscriptionStatus as a prop to each PostCard component so they can enforce subscription gating for the 'Go Public' button. Ensure the component handles loading and error states gracefully."
        }
      ]
    }
  ]
}